package msix

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/scttfrdmn/bagboy/pkg/config"
)

type Packager struct{}

func New() *Packager {
	return &Packager{}
}

func (p *Packager) Name() string {
	return "msix"
}

func (p *Packager) Validate(cfg *config.Config) error {
	for arch := range cfg.Binaries {
		if strings.HasPrefix(arch, "windows-") {
			return nil
		}
	}
	return fmt.Errorf("no Windows binary found for MSIX creation")
}

func (p *Packager) Pack(ctx context.Context, cfg *config.Config) (string, error) {
	var windowsBinary string
	for arch, path := range cfg.Binaries {
		if strings.HasPrefix(arch, "windows-") {
			windowsBinary = path
			break
		}
	}

	msixDir := filepath.Join("dist", "msix")
	if err := os.MkdirAll(msixDir, 0755); err != nil {
		return "", err
	}

	// Create AppxManifest.xml
	manifestPath := filepath.Join(msixDir, "AppxManifest.xml")
	if err := p.createManifest(manifestPath, cfg); err != nil {
		return "", err
	}

	// Create build script
	buildScriptPath := filepath.Join(msixDir, "build-msix.ps1")
	if err := p.createBuildScript(buildScriptPath, cfg, windowsBinary); err != nil {
		return "", err
	}

	// Create mock MSIX
	outputPath := filepath.Join("dist", fmt.Sprintf("%s-%s.msix", cfg.Name, cfg.Version))
	mockMSIX := fmt.Sprintf("# Mock MSIX for %s %s\n# Generated by bagboy\n# Modern Windows app package\n# Run: cd %s && .\\build-msix.ps1\n", cfg.Name, cfg.Version, msixDir)
	if err := os.WriteFile(outputPath, []byte(mockMSIX), 0644); err != nil {
		return "", err
	}

	return outputPath, nil
}

func (p *Packager) createManifest(path string, cfg *config.Config) error {
	tmpl := `<?xml version="1.0" encoding="utf-8"?>
<Package xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
         xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10">
  <Identity Name="{{.PackageId}}"
            Version="{{.Version}}.0"
            Publisher="CN={{.Publisher}}"
            ProcessorArchitecture="x64" />
  
  <Properties>
    <DisplayName>{{.Name}}</DisplayName>
    <PublisherDisplayName>{{.Publisher}}</PublisherDisplayName>
    <Description>{{.Description}}</Description>
    <Logo>Assets\StoreLogo.png</Logo>
  </Properties>
  
  <Dependencies>
    <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.19041.0" MaxVersionTested="10.0.22000.0" />
  </Dependencies>
  
  <Applications>
    <Application Id="{{.Name}}" Executable="{{.Name}}.exe" EntryPoint="Windows.FullTrustApplication">
      <uap:VisualElements DisplayName="{{.Name}}"
                          Description="{{.Description}}"
                          BackgroundColor="transparent"
                          Square150x150Logo="Assets\Square150x150Logo.png"
                          Square44x44Logo="Assets\Square44x44Logo.png">
      </uap:VisualElements>
    </Application>
  </Applications>
  
  <Capabilities>
    <Capability Name="internetClient" />
    <Capability Name="privateNetworkClientServer" />
  </Capabilities>
</Package>`

	t, err := template.New("manifest").Parse(tmpl)
	if err != nil {
		return err
	}

	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	publisher := cfg.Author
	if strings.Contains(cfg.Author, "<") {
		parts := strings.Split(cfg.Author, "<")
		publisher = strings.TrimSpace(parts[0])
	}

	data := struct {
		*config.Config
		PackageId string
		Publisher string
	}{
		Config:    cfg,
		PackageId: fmt.Sprintf("com.%s.%s", strings.ToLower(publisher), strings.ToLower(cfg.Name)),
		Publisher: publisher,
	}

	return t.Execute(f, data)
}

func (p *Packager) createBuildScript(path string, cfg *config.Config, binaryPath string) error {
	tmpl := `# PowerShell script to build MSIX package for {{.Name}}
# Requires Windows SDK and MakeAppx.exe

param(
    [switch]$Sign
)

$AppName = "{{.Name}}"
$Version = "{{.Version}}"
$BinaryPath = "{{.BinaryPath}}"
$MSIXFile = "$AppName-$Version.msix"

Write-Host "Building MSIX package for $AppName v$Version..." -ForegroundColor Green

# Create package structure
$PackageDir = "package"
if (Test-Path $PackageDir) { Remove-Item $PackageDir -Recurse -Force }
New-Item -ItemType Directory -Path $PackageDir -Force | Out-Null
New-Item -ItemType Directory -Path "$PackageDir\Assets" -Force | Out-Null

# Copy files
Copy-Item "AppxManifest.xml" "$PackageDir\"
Copy-Item $BinaryPath "$PackageDir\$AppName.exe"

# Create placeholder assets (in production, use real icons)
$PlaceholderIcon = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=="
[System.IO.File]::WriteAllBytes("$PackageDir\Assets\StoreLogo.png", [System.Convert]::FromBase64String($PlaceholderIcon))
[System.IO.File]::WriteAllBytes("$PackageDir\Assets\Square150x150Logo.png", [System.Convert]::FromBase64String($PlaceholderIcon))
[System.IO.File]::WriteAllBytes("$PackageDir\Assets\Square44x44Logo.png", [System.Convert]::FromBase64String($PlaceholderIcon))

# Build MSIX
try {
    $MakeAppx = Get-Command "MakeAppx.exe" -ErrorAction Stop
    & $MakeAppx pack /d $PackageDir /p $MSIXFile /o
    
    if ($LASTEXITCODE -eq 0) {
        Write-Host "✅ Created $MSIXFile" -ForegroundColor Green
        
        if ($Sign) {
            Write-Host "Signing package..." -ForegroundColor Yellow
            # In production, use real certificate
            Write-Host "⚠️  Package signing requires a valid certificate" -ForegroundColor Yellow
        }
        
        Write-Host ""
        Write-Host "Installation:" -ForegroundColor Cyan
        Write-Host "  Add-AppxPackage $MSIXFile" -ForegroundColor White
    } else {
        Write-Error "Failed to create MSIX package"
    }
} catch {
    Write-Error "MakeAppx.exe not found. Install Windows SDK."
}`

	t, err := template.New("build").Parse(tmpl)
	if err != nil {
		return err
	}

	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	data := struct {
		*config.Config
		BinaryPath string
	}{
		Config:     cfg,
		BinaryPath: binaryPath,
	}

	return t.Execute(f, data)
}
