package dmg

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/scttfrdmn/bagboy/pkg/config"
)

type Packager struct{}

func New() *Packager {
	return &Packager{}
}

func (p *Packager) Name() string {
	return "dmg"
}

func (p *Packager) Validate(cfg *config.Config) error {
	// Find macOS binary
	for arch := range cfg.Binaries {
		if strings.HasPrefix(arch, "darwin-") {
			return nil
		}
	}
	return fmt.Errorf("no macOS binary found for DMG creation")
}

func (p *Packager) Pack(ctx context.Context, cfg *config.Config) (string, error) {
	// Find macOS binary
	var darwinBinary string
	for arch, path := range cfg.Binaries {
		if strings.HasPrefix(arch, "darwin-") {
			darwinBinary = path
			break
		}
	}

	dmgDir := filepath.Join("dist", "dmg")
	if err := os.MkdirAll(dmgDir, 0755); err != nil {
		return "", err
	}

	// Create DMG contents directory
	contentsDir := filepath.Join(dmgDir, "contents")
	if err := os.MkdirAll(contentsDir, 0755); err != nil {
		return "", err
	}

	// Copy binary to contents
	binaryDest := filepath.Join(contentsDir, cfg.Name)
	if err := p.copyFile(darwinBinary, binaryDest); err != nil {
		return "", err
	}
	if err := os.Chmod(binaryDest, 0755); err != nil {
		return "", err
	}

	// Create Applications symlink for drag-to-install
	if err := os.Symlink("/Applications", filepath.Join(contentsDir, "Applications")); err != nil {
		// Ignore error if symlink already exists
	}

	// Create build script for DMG creation
	buildScriptPath := filepath.Join(dmgDir, "build-dmg.sh")
	if err := p.createBuildScript(buildScriptPath, cfg); err != nil {
		return "", err
	}

	// Create DS_Store template for nice DMG layout
	dsStorePath := filepath.Join(dmgDir, "DS_Store_template")
	if err := p.createDSStoreTemplate(dsStorePath, cfg); err != nil {
		return "", err
	}

	// Create mock DMG file (in production would use hdiutil)
	outputPath := filepath.Join("dist", fmt.Sprintf("%s-%s.dmg", cfg.Name, cfg.Version))
	mockDMG := fmt.Sprintf("# Mock DMG for %s %s\n# Generated by bagboy\n# In production, run: cd %s && ./build-dmg.sh\n", cfg.Name, cfg.Version, dmgDir)
	if err := os.WriteFile(outputPath, []byte(mockDMG), 0644); err != nil {
		return "", err
	}

	return outputPath, nil
}

func (p *Packager) createBuildScript(path string, cfg *config.Config) error {
	tmpl := `#!/bin/bash
set -e

# Build script for {{.Name}} DMG

APP_NAME="{{.Name}}"
VERSION="{{.Version}}"
DMG_NAME="${APP_NAME}-${VERSION}.dmg"
VOLUME_NAME="${APP_NAME} ${VERSION}"
SOURCE_DIR="contents"
TEMP_DMG="temp.dmg"

echo "Creating DMG for ${APP_NAME} v${VERSION}..."

# Clean up any existing files
rm -f "${DMG_NAME}" "${TEMP_DMG}"

# Create temporary DMG
hdiutil create -srcfolder "${SOURCE_DIR}" -volname "${VOLUME_NAME}" -fs HFS+ \
    -fsargs "-c c=64,a=16,e=16" -format UDRW -size 100m "${TEMP_DMG}"

# Mount the temporary DMG
DEVICE=$(hdiutil attach -readwrite -noverify -noautoopen "${TEMP_DMG}" | \
    egrep '^/dev/' | sed 1q | awk '{print $1}')
MOUNT_POINT="/Volumes/${VOLUME_NAME}"

# Wait for mount
sleep 2

# Set up the DMG layout
echo "Setting up DMG layout..."

# Copy DS_Store for layout
if [ -f "DS_Store_template" ]; then
    cp DS_Store_template "${MOUNT_POINT}/.DS_Store"
fi

# Set background and layout (requires AppleScript)
osascript << EOF
tell application "Finder"
    tell disk "${VOLUME_NAME}"
        open
        set current view of container window to icon view
        set toolbar visible of container window to false
        set statusbar visible of container window to false
        set the bounds of container window to {400, 100, 900, 400}
        set viewOptions to the icon view options of container window
        set arrangement of viewOptions to not arranged
        set icon size of viewOptions to 72
        set position of item "${APP_NAME}" of container window to {150, 200}
        set position of item "Applications" of container window to {350, 200}
        close
        open
        update without registering applications
        delay 2
    end tell
end tell
EOF

# Unmount
hdiutil detach "${DEVICE}"

# Convert to final DMG
hdiutil convert "${TEMP_DMG}" -format UDZO -imagekey zlib-level=9 -o "${DMG_NAME}"

# Clean up
rm -f "${TEMP_DMG}"

echo "âœ… Created ${DMG_NAME}"
echo ""
echo "Usage:"
echo "  Open ${DMG_NAME} and drag ${APP_NAME} to Applications"`

	t, err := template.New("build").Parse(tmpl)
	if err != nil {
		return err
	}

	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	if err := os.Chmod(path, 0755); err != nil {
		return err
	}

	return t.Execute(f, cfg)
}

func (p *Packager) createDSStoreTemplate(path string, cfg *config.Config) error {
	// Create a simple DS_Store template file
	// In production, this would be a binary DS_Store file for layout
	template := fmt.Sprintf("# DS_Store template for %s DMG\n# This would be a binary .DS_Store file in production\n# Controls icon positions and window layout\n", cfg.Name)
	return os.WriteFile(path, []byte(template), 0644)
}

func (p *Packager) copyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	_, err = dstFile.ReadFrom(srcFile)
	return err
}
